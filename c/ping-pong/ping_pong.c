// "Пинг-понг" с N каналами
// Задание:
// Реализовать игру в «ping-pong» для 3 процессов (кому мало, можно для произвольного N>=2 , N задавать в командной строке).
// Главный процесс порождает двух (N-1) потомков по любой схеме (2 сына или сын-внук) и начинает передачу данных. Начальное и конечное целые числа переданы в командной строке. Принимающий увеличивает число на 1 и передает дальше, и так по кругу до тех пор, пока число не превысит заданный максимум.
// Каждый процесс выводит на экран текущее число и свой pid.
// Обмен данными через каналы (каждая пара процессов связана отдельным каналом).
// Обмен данными через один канал. Синхронизация обращений к каналу должна быть организована с помощью сигналов.
// Обратите внимание на завершение работы, лишних чисел выводиться не должно.

// Протестировать работу сигналов в используемой Вами системе. Написать тестовые программы, которые позволяют ответить на эти вопросы, и дать комментарий по поводу результатов — что у вас получилось.
// 1) Сбрасывается ли обработка сигнала на значение по умолчанию после вызова обработчика, если нет явной переустановки?
// 2) Блокируется ли на время работы обработчика
//    а) тот же сигнал, что в данный момент обрабатывается,
// 	  б) другие сигналы?
// 3) При посылке сигнала всей своей группе получает ли этот сигнал тот процесс, который его отправляет?
// 4) Возобновляет ли работу функция wait(), если во время ожидания пришел сигнал, или она завершается с ошибкой?

// Замечания по программе:
// 1) вид командной строки: ./prog N a b
// где N - количество процессов
// a - начальное значение
// b - конечное значение
// 2) в программе предусмотрена проверка входных данных
// 3) если a > b, то программа просто завершается, то есть никаких
// новых процессов не создается (слишком уж бессмысленно)
// в противном случае, порождается ровно N процессов
// (даже если количество выводимых чисел < N)

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>

void close_fd (int prev, int next, int fd[][2], int N);
void process (pid_t pid, int fd0, int fd1, int max);

int main (int argc, char *argv[]) {
// проверка на количество введенных параметров	
	if (argc != 4) {
		printf("Number of parameters: %d is incorrect\n", argc-1);
		return 0;
	}
// считывание количества процессов N, проверка значения
	int N = atoi(argv[1]);
	if (N < 2) {
		printf("Number of processes N should be >= 2\n");
		return 0;
	}
// инициализация, считывание диапазона [a, b]
// если a > b, то программа просто завершается
	pid_t p;
	int fd[N][2];
	int i, prev, next, cur = atoi(argv[2]), max = atoi(argv[3]);
	if (cur > max)
		return 0;
// cоздание каналов
	for (i=0; i<N; i++)
		pipe(fd[i]);
// настраиваем индексы для обращения к массиву файловых дискрипторов
	prev = N-1;
	next = 0;
// для нормального запуска цикла и синхронизации кладем в последний канал входное число	
	write(fd[prev][1], &cur, sizeof(int));
	for (i=1; ; i++) {
// порождаем детей, внуков и т.д. и запускаем игру в "пинг-понг"
		if (i<N) {
			if ((p = fork()) < 0) {
				perror("fork");
				close_fd (0, 0, fd, N);
				exit(0); 
			}
		}
		else // i = N, p = 0;
			p++; // чтобы пра..правнук (последний) почувствовал себя родителем
		if (p) { // родитель или пра..правнук (последний)
			p = getpid(); // чтобы каждый раз не вызывать функцию
			close_fd(prev, next, fd, N); // закрытие ненужных дискрипторов
			process(p, fd[prev][0], fd[next][1], max);
		}
		else  // сын
			prev = next++;	
	}
	return 0;
}

void process (pid_t pid, int fd0, int fd1, int max) {
	int cur;
	for (;;) {
		read(fd0, &cur, sizeof(int));
		if (cur <= max)
			printf("pid = %d, number = %d\n", pid, cur++);
		write(fd1, &cur, sizeof(int));
		if (cur > max) {
			close(fd0); close(fd1);
			exit(0);
		}
	}
	return;
}

void close_fd (int prev, int next, int fd[][2], int N) {
	int i;
	close(fd[prev][1]);
	close(fd[next][0]);
	for (i=(next + 1) % N; i != prev; i %= N) {
		close(fd[i][0]);
		close(fd[i][1]);
		i++;
	}
	return;
}